<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Bi·ªÉu ƒë·ªì d·ªØ li·ªáu n∆∞·ªõc</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
    body { font-family: sans-serif; margin: 20px; }
    .controls { margin-bottom: 10px; display: flex; gap: 10px; flex-wrap: wrap; }
    
    @keyframes blink {
        0%, 50% { opacity: 1; }
        51%, 100% { opacity: 0.3; }
    }
    
    .status-container {
        background-color: #f5f5f5;
        padding: 10px;
        border-radius: 5px;
        margin-bottom: 10px;
    }
    </style>
</head>
<body>
    <h2>Bi·ªÉu ƒë·ªì nhi·ªát ƒë·ªô v√† ƒë·ªô ƒë·ª•c theo th·ªùi gian</h2>

    <div class="controls">
        <label>T·ª´: <input type="date" id="from-date"></label>
        <label>ƒê·∫øn: <input type="date" id="to-date"></label>
        <button onclick="loadHistory()">L·ªçc d·ªØ li·ªáu</button>
        <button onclick="enableRealtime()">Ch·∫ø ƒë·ªô th·ªùi gian th·ª±c</button>
    </div>

    <div class="controls">
        <label>ƒêi·ªÅu khi·ªÉn Servo:</label>
        <button onclick="controlServo(1)" style="background-color: #4CAF50; color: white; margin-right: 5px;">B·∫≠t Servo (1)</button>
        <button onclick="controlServo(0)" style="background-color: #f44336; color: white;">T·∫Øt Servo (0)</button>
        <span id="servo-status" style="margin-left: 10px; font-weight: bold;"></span>
    </div>

    <div class="controls">
        <label>Tr·∫°ng th√°i h·ªá th·ªëng:</label>
        <span id="food-level" style="margin-right: 15px; font-weight: bold; color: #2196F3;">Th·ª©c ƒÉn: --</span>
        <span id="person-detection" style="font-weight: bold; color: #FF9800;">Ng∆∞·ªùi: --</span>
    </div>

    <canvas id="myChart" width="600" height="300"></canvas>

    <script>
    const labels = []; // th·ªùi gian
    const tempData = []; // nhi·ªát ƒë·ªô
    const turbData = []; // ƒë·ªô ƒë·ª•c

    const ctx = document.getElementById('myChart').getContext('2d');
    const myChart = new Chart(ctx, {
        type: 'line',
        data: {
        labels: labels,
        datasets: [
            {
                label: 'Nhi·ªát ƒë·ªô (¬∞C)',
                data: tempData,
                borderWidth: 2,
                borderColor: 'red',
                fill: false
            },
            {
                label: 'ƒê·ªô ƒë·ª•c (ADC)',
                data: turbData,
                borderWidth: 2,
                borderColor: 'blue',
                fill: false
            }
        ]
        },
        options: {
            scales: {
                x: {
                    title: {
                        display: true,
                        text: 'Th·ªùi gian'
                    }
                },
                y: {
                beginAtZero: true
                }
            }
        }
    });

    // üì° Nh·∫≠n d·ªØ li·ªáu th·ªùi gian th·ª±c qua WebSocket
    const socket = new WebSocket('ws://localhost:3000');
    let isRealtimeMode = true; // Bi·∫øn ƒë·ªÉ ki·ªÉm so√°t ch·∫ø ƒë·ªô realtime

    socket.onmessage = (event) => {
    const json = JSON.parse(event.data);
    console.log('Realtime data:', json);

    // X·ª≠ l√Ω d·ªØ li·ªáu unified format
    if (json.temperature !== undefined && json.turbidity !== undefined) {
        // D·ªØ li·ªáu sensor (nhi·ªát ƒë·ªô, ƒë·ªô ƒë·ª•c) - ch·ªâ c·∫≠p nh·∫≠t bi·ªÉu ƒë·ªì khi ·ªü ch·∫ø ƒë·ªô realtime
        if (isRealtimeMode) {
            // Ch·ªâ hi·ªÉn th·ªã ng√†y, b·ªè gi·ªù
            const dateOnly = json.timestamp.split(' ')[0] || json.timestamp.split('T')[0];
            labels.push(dateOnly);
            tempData.push(json.temperature);
            turbData.push(json.turbidity);

            // Ch·ªâ gi·ªØ l·∫°i 10 ƒëi·ªÉm g·∫ßn nh·∫•t
            if (labels.length > 10) {
                labels.shift();
                tempData.shift();
                turbData.shift();
            }

            myChart.update();
        }
    }

    // C·∫≠p nh·∫≠t tr·∫°ng th√°i thi·∫øt b·ªã (lu√¥n c·∫≠p nh·∫≠t, kh√¥ng ph·ª• thu·ªôc v√†o realtime mode)
    if (json.distance !== undefined) {
        updateFoodLevel(json.distance);
    }
    
    if (json.PIR !== undefined) {
        updatePersonDetection(json.PIR);
    }
    };


    // üì• T·∫£i d·ªØ li·ªáu c≈© t·ª´ Firebase th√¥ng qua server
    async function loadHistory() {
        const from = document.getElementById('from-date').value;
        const to = document.getElementById('to-date').value;
        if (!from || !to) {
        alert('Vui l√≤ng ch·ªçn c·∫£ ng√†y b·∫Øt ƒë·∫ßu v√† k·∫øt th√∫c!');
        return;
        }

        // T·∫Øt ch·∫ø ƒë·ªô realtime khi l·ªçc d·ªØ li·ªáu
        isRealtimeMode = false;

        try {
            const response = await fetch(`http://localhost:3000/data_sensor?from=${from}&to=${to}`);
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const data = await response.json();
            console.log('D·ªØ li·ªáu l·ªãch s·ª≠:', data);

            // Xo√° d·ªØ li·ªáu c≈© tr√™n bi·ªÉu ƒë·ªì
            labels.length = 0;
            tempData.length = 0;
            turbData.length = 0;

            data.forEach(d => {
            // Ch·ªâ hi·ªÉn th·ªã ng√†y, b·ªè gi·ªù
            const dateOnly = d.timestamp.split(' ')[0] || d.timestamp.split('T')[0];
            labels.push(dateOnly);
            tempData.push(d.temperature);
            turbData.push(d.turbidity);
            });

            myChart.update();
        } catch (error) {
            console.error('L·ªói khi t·∫£i d·ªØ li·ªáu:', error);
            alert('Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu. Vui l√≤ng ki·ªÉm tra server!');
            // B·∫≠t l·∫°i realtime n·∫øu c√≥ l·ªói
            isRealtimeMode = true;
        }
    }

    function enableRealtime() {
        isRealtimeMode = true;
        
        labels.length = 0;
        tempData.length = 0;
        turbData.length = 0;

        // T·ª± ƒë·ªông c·∫≠p nh·∫≠t ng√†y h√¥m qua v√† h√¥m nay
        const today = new Date();
        const yesterday = new Date(today.getTime() - 24 * 60 * 60 * 1000);
        
        // Chuy·ªÉn ƒë·ªïi th√†nh ƒë·ªãnh d·∫°ng YYYY-MM-DD theo m√∫i gi·ªù ƒë·ªãa ph∆∞∆°ng
        const formatDate = (date) => {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        };
        
        document.getElementById('to-date').value = formatDate(today);
        document.getElementById('from-date').value = formatDate(yesterday);

        myChart.update();
        console.log('ƒê√£ b·∫≠t ch·∫ø ƒë·ªô th·ªùi gian th·ª±c');
    }

    // üéõÔ∏è H√†m ƒëi·ªÅu khi·ªÉn servo
    async function controlServo(value) {
        try {
            const statusElement = document.getElementById('servo-status');
            statusElement.textContent = 'ƒêang g·ª≠i l·ªánh...';
            statusElement.style.color = 'orange';

            const response = await fetch('http://localhost:3000/control/servo', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ value: value })
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const result = await response.json();
            console.log('Servo control result:', result);
            
            // C·∫≠p nh·∫≠t tr·∫°ng th√°i
            statusElement.textContent = value === 1 ? 'Servo: B·∫¨T' : 'Servo: T·∫ÆT';
            statusElement.style.color = value === 1 ? 'green' : 'red';
            
        } catch (error) {
            console.error('L·ªói khi ƒëi·ªÅu khi·ªÉn servo:', error);
            const statusElement = document.getElementById('servo-status');
            statusElement.textContent = 'L·ªói k·∫øt n·ªëi!';
            statusElement.style.color = 'red';
        }
    }

    // H√†m c·∫≠p nh·∫≠t l∆∞·ª£ng th·ª©c ƒÉn d·ª±a v√†o distance
    function updateFoodLevel(distanceInCm) {
        const foodElement = document.getElementById('food-level');
        
        if (distanceInCm === undefined || distanceInCm === null) {
            foodElement.textContent = 'Th·ª©c ƒÉn: --';
            foodElement.style.color = '#999';
            return;
        }

        // Chuy·ªÉn ƒë·ªïi distance t·ª´ ƒë∆°n v·ªã m√† sensor tr·∫£ v·ªÅ (c√≥ th·ªÉ l√† mm ho·∫∑c raw value)
        // Gi·∫£ ƒë·ªãnh: distance l√† gi√° tr·ªã ADC ho·∫∑c mm, c·∫ßn map v·ªÅ cm

        // T√≠nh to√°n m·ª©c th·ª©c ƒÉn (distance c√†ng l·ªõn = th·ª©c ƒÉn c√†ng √≠t)
        let foodLevel;
        let levelText;
        let color;

        if (distanceInCm <= 3) {
            foodLevel = 100;
            levelText = 'ƒê·∫¶Y';
            color = '#4CAF50'; // Xanh l√°
        } else if (distanceInCm <= 6) {
            foodLevel = 75;
            levelText = 'NHI·ªÄU';
            color = '#8BC34A'; // Xanh l√° nh·∫°t
        } else if (distanceInCm <= 10) {
            foodLevel = 50;
            levelText = 'TRUNG B√åNH';
            color = '#FF9800'; // Cam
        } else if (distanceInCm <= 15) {
            foodLevel = 25;
            levelText = '√çT';
            color = '#FF5722'; // Cam ƒë·ªè
        } else {
            foodLevel = 0;
            levelText = 'H·∫æT';
            color = '#F44336'; // ƒê·ªè
        }

        foodElement.textContent = `Th·ª©c ƒÉn: ${levelText} (${distanceInCm.toFixed(1)}cm)`;
        foodElement.style.color = color;

        // C·∫£nh b√°o khi h·∫øt th·ª©c ƒÉn
        if (foodLevel <= 25) {
            foodElement.style.fontWeight = 'bold';
            if (foodLevel === 0) {
                foodElement.style.animation = 'blink 1s infinite';
            }
        } else {
            foodElement.style.animation = 'none';
        }
    }

    // üë§ H√†m c·∫≠p nh·∫≠t ph√°t hi·ªán ng∆∞·ªùi
    function updatePersonDetection(pirValue) {
        const personElement = document.getElementById('person-detection');
        
        if (pirValue === undefined || pirValue === null) {
            personElement.textContent = 'Ng∆∞·ªùi: --';
            personElement.style.color = '#999';
            return;
        }

        // PIR sensor: 1 = c√≥ chuy·ªÉn ƒë·ªông, 0 = kh√¥ng c√≥ chuy·ªÉn ƒë·ªông
        if (pirValue === 1 || pirValue === '1' || pirValue === true) {
            personElement.textContent = 'Ng∆∞·ªùi: C√ì NG∆Ø·ªúI';
            personElement.style.color = '#4CAF50'; // Xanh l√°
            personElement.style.fontWeight = 'bold';
        } else {
            personElement.textContent = 'Ng∆∞·ªùi: KH√îNG C√ì';
            personElement.style.color = '#999'; // X√°m
            personElement.style.fontWeight = 'normal';
        }
    }

    // üïí T·ª± ƒë·ªông set ng√†y h√¥m nay v√† h√¥m qua
    window.onload = () => {
        const today = new Date();
        const yesterday = new Date(today.getTime() - 24 * 60 * 60 * 1000);
        
        // Chuy·ªÉn ƒë·ªïi th√†nh ƒë·ªãnh d·∫°ng YYYY-MM-DD theo m√∫i gi·ªù ƒë·ªãa ph∆∞∆°ng
        const formatDate = (date) => {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        };
        
        document.getElementById('to-date').value = formatDate(today);
        document.getElementById('from-date').value = formatDate(yesterday);
        
        // T·∫£i tr·∫°ng th√°i thi·∫øt b·ªã ban ƒë·∫ßu
        loadDeviceStatus();
    };

    // üì° H√†m t·∫£i tr·∫°ng th√°i thi·∫øt b·ªã ban ƒë·∫ßu
    async function loadDeviceStatus() {
        try {
            const today = new Date();
            const todayStr = today.getFullYear() + '-' + 
                           String(today.getMonth() + 1).padStart(2, '0') + '-' + 
                           String(today.getDate()).padStart(2, '0');
            
            // T·∫£i d·ªØ li·ªáu sensor m·ªõi nh·∫•t ƒë·ªÉ l·∫•y tr·∫°ng th√°i thi·∫øt b·ªã
            const response = await fetch(`http://localhost:3000/data_sensor?from=${todayStr}&to=${todayStr}`);
            
            if (response.ok) {
                const data = await response.json();
                if (data.length > 0) {
                    const latestStatus = data[data.length - 1]; // L·∫•y d·ªØ li·ªáu m·ªõi nh·∫•t
                    
                    // C·∫≠p nh·∫≠t UI v·ªõi d·ªØ li·ªáu m·ªõi nh·∫•t
                    if (latestStatus.distance !== undefined) {
                        updateFoodLevel(latestStatus.distance);
                    }
                    
                    if (latestStatus.PIR !== undefined) {
                        updatePersonDetection(latestStatus.PIR);
                    }
                }
            }
        } catch (error) {
            console.log('Kh√¥ng th·ªÉ t·∫£i tr·∫°ng th√°i thi·∫øt b·ªã ban ƒë·∫ßu:', error);
        }
    }
</script>
</body>
</html>
