const push = require('pushsafer-notifications');
// C·∫•u h√¨nh Pushsafer
const pushsafer = new push({
    k: 'GW0MQdXUPoRzXkiTgKaR',
    debug: false
});


// Import h√†m g·ª≠i email
const { sendNotificationEmail } = require('./emailHandler');


// Bi·∫øn to√†n c·ª•c l∆∞u user m·ªõi nh·∫•t t·ª´ server
let UserMail = null;
// Tr·∫°ng th√°i ƒë·ªÉ tr√°nh spam th√¥ng b√°o
let lastNotifications = {
    lowFood: 0,
    highTurbidity: 0
};

const NOTIFICATION_COOLDOWN = 5 * 60 * 1000; // 5 ph√∫t cooldown

function sendPushsaferNotification(title, message, user, sound = 0, vibration = 1, icon = 4) {
    // G√°n user v√†o bi·∫øn to√†n c·ª•c ƒë·ªÉ c√°c h√†m kh√°c d√πng ƒë∆∞·ª£c
    UserMail = user.username;
    return new Promise((resolve, reject) => {
        const msg = {
            m: message + '\nUser: ' + JSON.stringify(user),
            t: title,
            s: sound,
            v: vibration,
            i: icon,
            d: 'a'
        };
        pushsafer.send(msg, (err, result) => {
            if (err) {
                console.error('‚ùå Pushsafer error:', err);
                reject(err);
            } else {
                console.log('‚úÖ Pushsafer notification sent');
                resolve(result);
            }
        });
    });
}

// Ki·ªÉm tra th·ª©c ƒÉn
function checkFoodLevel(distanceInCm) {
    const now = Date.now();
    let foodLevel, levelText;

    if (distanceInCm <= 3) {
        foodLevel = 100; levelText = 'ƒê·∫¶Y';
    } else if (distanceInCm <= 6) {
        foodLevel = 75; levelText = 'NHI·ªÄU';
    } else if (distanceInCm <= 10) {
        foodLevel = 50; levelText = 'TRUNG B√åNH';
    } else if (distanceInCm <= 15) {
        foodLevel = 25; levelText = '√çT';
    } else {
        foodLevel = 0; levelText = 'H·∫æT';
    }

    if (foodLevel <= 25 && (now - lastNotifications.lowFood) > NOTIFICATION_COOLDOWN) {
        const title = 'Th√¥ng b√°o th·ª©c ƒÉn c√°';
        const message = `M·ª©c th·ª©c ƒÉn: ${foodLevel}% (${levelText})\nVui l√≤ng b·ªï sung th·ª©c ƒÉn cho c√°!`;

        // G·ª≠i push notification
        sendPushsaferNotification(title, message).catch(error => {
            console.error('Failed to send food notification:', error);
        });

        // G·ª≠i email notification
        sendNotificationEmail(UserMail, title, message).catch(error => {
            console.error('Failed to send food email:', error);
        });

        lastNotifications.lowFood = now;
        console.log(`üì± Sent food notification: ${foodLevel}% (${levelText})`);
    }
}

// Ki·ªÉm tra ƒë·ªô ƒë·ª•c
function checkTurbidity(turbidity) {
    turbidity = 100 - turbidity;
    const now = Date.now();
    
    if (turbidity > 80 && (now - lastNotifications.highTurbidity) > NOTIFICATION_COOLDOWN) {
        let levelText;

        if (turbidity > 95) {
            levelText = 'r·∫•t ƒë·ª•c';
        } else if (turbidity > 90) {
            levelText = 'ƒë·ª•c';
        } else {
            levelText = 'h∆°i ƒë·ª•c';
        }

        const title = 'Th√¥ng b√°o ch·∫•t l∆∞·ª£ng n∆∞·ªõc';
        const message = `ƒê·ªô ƒë·ª•c n∆∞·ªõc: ${turbidity}% (${levelText})\nC·∫ßn ki·ªÉm tra v√† l√†m s·∫°ch b·ªÉ c√°!`;

        // G·ª≠i push notification
        sendPushsaferNotification(title, message).catch(error => {
            console.error('Failed to send turbidity notification:', error);
        });
        console.log('User email for turbidity notification:', UserMail);
        // G·ª≠i email notification
        sendNotificationEmail(UserMail, title, message).catch(error => {
            console.error('Failed to send turbidity email:', error);
        });
        lastNotifications.highTurbidity = now;
        console.log(`üì± Sent turbidity notification: ${turbidity}% (${levelText})`);
    }
}

// X·ª≠ l√Ω d·ªØ li·ªáu sensor
function processSensorData(data) {
 
    if (data.distance !== undefined) {
        checkFoodLevel(data.distance);
    }
    
    if (data.turbidity !== undefined) {
        checkTurbidity(data.turbidity);
    }
}

module.exports = {
    sendPushsaferNotification,
    processSensorData,
    checkFoodLevel,
    checkTurbidity
};